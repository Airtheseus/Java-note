# Java noteboook

JDK:java development kit 包含JRE和编译运行等开发工具
JRE:java runtime environment 包含JVM和系统类库
编译
java文件编译：xx.java->字节码文件xx.class  jvm   操作系统

变量
精确运算场合要用bigdecrinal

java构造子类之前必须先构造父类，若子类中没有构造函数，则系统默认的子类构造函数中会添加super()，若子类中定义了构造函数，则super()要放在第一行，避免在未构造父类的情况下调用父类的成员
Java类中若自定义了构造函数则默认的构造函数将不再生效
Jvm把内存分为堆 堆栈 和方法区，对不再使用的对象设为null能今早进行垃圾回收，避免内存泄露
Java向上造型性质
父类类型的引用指向子类对象
Java包解决命名冲突，同一个包中的类名不能重复
调试
F5单步，进函数
单步，不进函数
跳出当前函数
运行至下一个断点或结束
右键选中watch能监控变量和表达式

内部类
内部类可以直接访问外部类的成员，包括私有成员，内部类在实现时隐式传入了外部类对象，因此能依靠类对象访问外部类成员
匿名类
一般用于某类只想创建一次对象，并且只有一个，不用命名
Father foo = new Father(){}
匿名类同样拥有独立的.class文件
若某方法是全部子类的共有方法，则放入父类
若某方法是部分子类的共有方法，则放入接口
一个类对象能向上造型的类型有
该类的父类
该类实现的接口

对象的强制类型转换
可以通过强制类型转换将父类对象转换成子类类型对象，前提是该父类类型对象是子类对象的引用
可以通过强制类型转换将对象转换为某接口类型，前提是该对象实现了该接口类型
为了避免出现class cast exception，可以通过instance of关键字判断某个引用指向的对象是否为指定类型

文档注释
*功能说明
*@author作者
*@version版本
*@see参见...
*@JDK1.0始于jdk的版本
==运算符比较的是对象而不是其中的数据
java的8个基本类型是不具备面向对象性质的

String
是不可变对象，也不可以被继承
字符串一旦被创建就无法改变其值，但引用可以重新赋值，表面上看上去是字符串值变了，实际上是重新开辟了内存空间进行赋值，原来引用的那块内存的值没变，即所谓的字符串值不可变，若频繁修改字符串，会造成很大的内存开销，GC开销。字符串内容计算建议使用stringbuilder，string的链接过程实际上就是用stringbuilder实现的，stringbuffer线程安全效率略低，stringbuilder非线程安全效率略高

线程调度的不可控性
一个线程会被分多久的时间片
下一个时间片会执行哪个线程

3.11
移位操作
有符号>>高位根据正负，正补0负补1
<<低位补0
无符号右移补0，无左移

Java无sizeof，这在c/c++中跨平台的特性在java中不需要考虑

4.7
Java中使用标签的唯一场景是用于跳出多层嵌套的循环，break+标签跳出到指定标签，并不再执行标签对应的循环，continue+标签还会执行标签对应的循环

5.2
引入重载函数的原因
解决类似c语言每个函数必须不同名的缺点
构造器的引入必须要求有重载，因为一般都有无参构造和有参构造

5.2.2
小字节类型向大字节类型转换能自动完成，大字节类型向小字节类型转换需进行强制类型转换，重载和传参时应注意

5.4.1
类的常规方法中禁止调用构造器，一个构造器中可以通过this调用其他构造器，但只能调用一个，并且不能直接通过构造器函数名调用构造器

7.3
组合语法，即在类中使用其他类对象

7.2
可以为每一个类设置一个mail函数，使每个类进行单元测试
默认访问权限是包访问权限，若一个类的方法设置了默认权限，则不在同一个包中的类继承该类将无法调用该方法，要设置成public

7.3
介于组合和继承两个特性之间的复用类方法：代理，创建一个代理类，类中声明想继承的类对象，然后定义方法封装该对象具有的方法，然后创建代理类的对象访问要继承的类的方法

7.4
子类重写父类的方法会覆盖父类方法，但重载不会覆盖

7.5
组合和继承的选择相当于现实中对象间的关系，猫是动物但猫不包含动物，因此猫和动物是继承关系，不是组合关系，is-a关系用继承，has-a关系用组合

7.7.2
按该节的说法，是否要用继承的一个清晰的判断方法是，是否需要向上类类型转换，看了第八章后再思考

8.3
构造器中应尽量避免调用其他函数，或只调用final／private函数，因为普通函数有可能被子类覆盖而产生意想不到的结果

类实现某接口，则则也必须给接口中的每个方法提供实现

8.2.5
private 方法默认是final 的，却不能被子类重写覆盖

普通方法的调用才具有多态性，静态方法同样不具备多态性，因为静态方法不与具体对象相关联，具体调用哪个方法取决于该对象的类型
